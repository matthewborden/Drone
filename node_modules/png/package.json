{
  "name": "png",
  "version": "2.1.1",
  "main": "./build/Release/png",
  "description": "A C++ module for node-js that converts an RGB and RGBA buffers to PNG images (in memory).",
  "keywords": [
    "png",
    "rgb",
    "rgba",
    "image",
    "picture",
    "encode"
  ],
  "author": {
    "name": "Peteris Krumins",
    "email": "peteris.krumins@gmail.com",
    "url": "http://www.catonmat.net"
  },
  "license": {
    "type": "MIT"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/pkrumins/node-png.git"
  },
  "directories": {
    "examples": "examples",
    "src": "src"
  },
  "engines": {
    "node": ">=0.6.0"
  },
  "scripts": {
    "install": "node-waf configure build"
  },
  "readme": "This is a node.js module, writen in C++, that uses libpng to produce a PNG\r\nimage (in memory) from RGB or RGBA buffers.\r\n\r\nIt was written by Peteris Krumins (peter@catonmat.net).\r\nHis blog is at http://www.catonmat.net  --  good coders code, great reuse.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe module exports three objects: `Png`, `FixedPngStack` and `DynamicPngStack`.\r\n\r\nThe `Png` object is for creating PNG images from an RGB or RGBA buffer.\r\nThe `FixedPngStack` is for joining a number of PNGs together (stacking them\r\ntogether) on a transparent blackground.\r\nThe `DynamicPngStack` is for joining a number of PNGs together in the most\r\nspace efficient way (so that the canvas border matches the leftmost upper corner\r\nof some PNG and the rightmost bottom corner of some PNG).\r\n\r\n\r\nPng\r\n---\r\n\r\nThe `Png` object takes 4 arguments in its constructor:\r\n\r\n    var png = new Png(buffer, width, height, buffer_type);\r\n\r\nThe first argument, `buffer`, is a node.js `Buffer` filled with RGB(A) values.\r\nThe second argument is integer width of the image.\r\nThe third argument is integer height of the image.\r\nThe fourth argument is 'rgb', 'bgr', 'rgba or 'bgra'. Defaults to 'rgb'.\r\n\r\nThe constructed `png` object has the `encode` method that's asynchronous in nature.\r\nYou give it a callback and it will call your function with a node.js Buffer object\r\ncontaining the encoded PNG data when it's done:\r\n\r\n    png.encode(function (png_image) {\r\n        // ...\r\n    });\r\n\r\nThe constructed `png` object also has `encodeSync` method that does the encoding\r\nsynchronously and returns Buffer with PNG image data:\r\n\r\n    var png_image = png.encode();\r\n\r\nYou can either send the png_image to the browser, or write to a file, or\r\ndo something else with it. See `examples/` directory for some examples.\r\n\r\n\r\nFixedPngStack\r\n-------------\r\n\r\nThe `FixedPngStack` object takes 3 arguments in its constructor:\r\n\r\n    var fixed_png = new FixedPngStack(width, height, buffer_type);\r\n\r\nThe first argument is integer width of the canvas image.\r\nThe second argument is integer height of the canvas image.\r\nThe third argument is 'rgb', 'bgr', 'rgba or 'bgra'. Defaults to 'rgb'.\r\n\r\nNow you can use the `push` method of `fixed_png` object to push buffers\r\nto the canvas. The `push` method takes 5 arguments:\r\n\r\n    fixed_png.push(buffer, x, y, w, h);\r\n\r\nIt pushes an RGB(A) image in `buffer` of width `w` and height `h` to the canvas\r\nposition (x, y). You can push as many buffers to canvas as you want. After\r\nthat you should call `encode` method or `encodeSync` method that will join all\r\nthe pushed RGB(A) buffers together and return a single PNG.\r\n\r\nAll the regions that did not get covered will be transparent.\r\n\r\n\r\nDynamicPngStack\r\n---------------\r\n\r\nThe `DynamicPngStack` object doesn't take any dimension arguments because its\r\nwidth and height is dynamically computed. To create it, do:\r\n\r\n    var dynamic_png = new DynamicPngStack(buffer_type);\r\n\r\nThe `buffer_type` again is 'rgb', 'bgr', 'rgba' or 'bgra', depending on what type\r\nof buffers you're gonna push to `dynamic_png`.\r\n\r\nIt provides four methods - `push`, `encode`, `encodeSync`, and `dimensions`. The\r\n`push` and `encode` methods are the same as in `FixedPngStack`. You `push` each\r\nof the RGB(A) buffers to the stack and after that you call `encode` or\r\n`encodeSync`.\r\n\r\nThe `encode` asynchronous method receives one more argument than others - it\r\nreceives the dimensions object with x, y, width and height of the dynamic PNG.\r\nSee the next paragraph for what the dimensions are.\r\n\r\nThe `dimensions` method is more interesting. It must be called only after\r\n`encode` as its values are calculated upon encoding the image. It returns an\r\nobject with `width`, `height`, `x` and `y` properties. The `width` and\r\n`height` properties show the width and the height of the final image. The `x`\r\nand `y` propreties show the position of the leftmost upper PNG.\r\n\r\nHere is an example that illustrates it. Suppose you wish to join two PNGs\r\ntogether. One with width 100x40 at position (5, 10) and the other with\r\nwidth 20x20 at position (2, 210). First you create the DynamicPngStack\r\nobject:\r\n\r\n    var dynamic_png = new DynamicPngStack();\r\n\r\nNext you push the RGB(A) buffers of the two PNGs to it:\r\n\r\n    dynamic_png.push(png1_buf, 5, 10, 100, 40);\r\n    dynamic_png.push(png2_buf, 2, 210, 20, 20);\r\n\r\nNow you can call `encode` to produce the final PNG:\r\n\r\n    var png = dynamic_png.encodeSync();\r\n\r\nNow let's see what the dimensions are,\r\n\r\n    var dims = dynamic_png.dimensions();\r\n\r\nSame asynchronously:\r\n\r\n    dynamic_png.encode(function (png, dims) {\r\n        // png is the PNG image (in a node.js Buffer)\r\n        // dims are its dimensions\r\n    });\r\n\r\nThe x position `dims.x` is 2 because the 2nd png is closer to the left.\r\nThe y position `dims.y` is 10 because the 1st png is closer to the top.\r\nThe width `dims.width` is 103 because the first png stretches from x=5 to\r\nx=105, but the 2nd png starts only at x=2, so the first two pixels are not\r\nnecessary and the width is 105-2=103.\r\nThe height `dims.height` is 220 because the 2nd png is located at 210 and\r\nits height is 20, so it stretches to position 230, but the first png starts\r\nat 10, so the upper 10 pixels are not necessary and height becomes 230-10= 220.\r\n\r\n\r\nHow to compile?\r\n---------------\r\n\r\nTo get the node-png module compiled, you need to have libpng and node.js\r\ninstalled. Then just run:\r\n\r\n    node-waf configure build\r\n\r\nto build node-png module. It will be called `png.node`. To use it, make sure\r\nit's in NODE_PATH.\r\n\r\nSee also http://github.com/pkrumins/node-jpeg module that produces JPEG images.\r\nAnd also http://github.com/pkrumins/node-gif for producing GIF images.\r\n\r\nIf you wish to stream PNGs over a websocket or xhr-multipart, you'll have to\r\nbase64 encode it. Use my http://github.com/pkrumins/node-base64 module to do\r\nthat.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nHave fun producing PNGs!\r\n\r\n\r\nSincerely,\r\nPeteris Krumins\r\nhttp://www.catonmat.net\r\n\r\n",
  "readmeFilename": "readme.txt",
  "_id": "png@2.1.1",
  "_from": "png"
}
